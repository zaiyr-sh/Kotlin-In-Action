package ch_5

import kotlin.contracts.contract

fun main() {
    // 5.1.2
    println("---------------5.1.2--------------")
    val people = listOf(Person("Alice", 29), Person("Bob", 31))
    println(people.maxByOrNull { it.age })
    println(people.maxByOrNull(Person::age))

    // 5.1.3
    println("---------------5.1.3--------------")
    val sum = { x: Int, y: Int -> x + y }
    println(sum(1, 2));
    { println(42) }() // call the lambda expression directly
    run { println(42) } // such invocations have no runtime overhead and are as efficient as built-in language constructs

    println(people.maxByOrNull({ p: Person -> p.age })) // without using any syntax shortcuts
    println(people.maxByOrNull() { p: Person -> p.age }) // move a lambda expression out of parentheses
    println(people.maxByOrNull { p: Person -> p.age }) // when lambda is only argument to a function, we can remove the empty parentheses from the call

    println(people.joinToString(separator = " ", transform = { p: Person -> p.name }))
    println(people.joinToString(" ") { p: Person -> p.name }) // lambda outside the parentheses

    println(people.maxByOrNull { p: Person -> p.age }) // parameter type explicitly written
    println(people.maxByOrNull { p -> p.age }) // parameter type inferred
    // The last simplification you can make is to replace a parameter with the default parameter name: it.
    // This name is generated if the context expects a lambda with only one argument, and its type can be inferred.
    println(people.maxByOrNull { it.age }) // "it" is an autogenerated parameter name

    // If you store a lambda in a variable, there’s no context from which to infer the parameter types,
    // so you have to specify them explicitly
    val getAge = { p: Person -> p.age }
    println(getAge)

    val computingSum = { x: Int, y: Int ->
        println("Computing the sum of $x and $y ...")
        x + y // the last expression is the result
    }
    println(computingSum(1, 2))

    // 5.1.4
    println("---------------5.1.4--------------")
    val errors = listOf("403 Forbidden", "404 Not Found")
    printMessagesWithPrefix(errors, "Error:")
    var responses = listOf("200 OK", "418 I'm a teapot", "500 Internal Server Errors")
    printProblemCounts(responses)

    val counter = Ref(0) // Class used to simulate capturing a mutable variable
    val inc = { counter.value++ } // Formally, an immutable variable is captured; but the actual value is stored in a field and can be changed
    println(inc.invoke())
    println(inc.invoke())
    // In real code, you don’t need to create such wrappers. Instead, you can mutate the variable directly.
    // The first example shows how the second example works under the hood
    var counter2 = 0
    val inc2 = { ++counter2 }
    println(inc2.invoke())
    println(inc2.invoke())

    // 5.1.5
    println("---------------5.1.5--------------")
    run(::salute)
}

// 5.1.2
data class Person(val name: String, val age: Int)

// 5.1.4
fun printMessagesWithPrefix(messages: Collection<String>, prefix: String) {
    messages.forEach {
        println("$prefix $it")
    }
}

fun printProblemCounts(responses: Collection<String>) {
    // Declares variables that will be accessed from the lambda
    var clientErrors = 0
    var serverErrors = 0
    responses.forEach {
        // modifies variables in the lambda
        if (it.startsWith("4")) {
            clientErrors++
        } else if (it.startsWith("5")) {
            serverErrors++
        }
    }
    println("$clientErrors client errors, $serverErrors server errors")
}

class Ref<T>(var value: T)

// 5.1.5
fun salute() = println("Salute")